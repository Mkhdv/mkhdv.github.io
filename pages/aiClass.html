<!DOCTYPE html>
<html lang="en">

<head>
    <!-- Google Tag Manager -->
    <script>(function (w, d, s, l, i) {
            w[l] = w[l] || []; w[l].push({
                'gtm.start':
                    new Date().getTime(), event: 'gtm.js'
            }); var f = d.getElementsByTagName(s)[0],
                j = d.createElement(s), dl = l != 'dataLayer' ? '&l=' + l : ''; j.async = true; j.src =
                    'https://www.googletagmanager.com/gtm.js?id=' + i + dl; f.parentNode.insertBefore(j, f);
        })(window, document, 'script', 'dataLayer', 'GTM-5TRR6T5');</script>
    <!-- End Google Tag Manager -->
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link rel="stylesheet" href="../css/style.css" />

    <script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/highlight.min.js"></script>

    <script>
        hljs.initHighlightingOnLoad();
    </script>

    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/styles/atom-one-light.min.css" />

    <!-- <script
      src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.2.0/highlight.min.js"
      integrity="sha512-TDKKr+IvoqZnPzc3l35hdjpHD0m+b2EC2SrLEgKDRWpxf2rFCxemkgvJ5kfU48ip+Y+m2XVKyOCD85ybtlZDmw=="
      crossorigin="anonymous"
    ></script> -->

    <!-- <link rel="stylesheet" href="/path/to/styles/atom-one-light.min.css" />
    <script src="/path/to/highlight.min.js"></script> -->

    <title>Game Playing Alorithm</title>
</head>

<body>
    <!-- Google Tag Manager (noscript) -->
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-5TRR6T5" height="0" width="0"
            style="display:none;visibility:hidden"></iframe></noscript>
    <!-- End Google Tag Manager (noscript) -->
    <div class="wrapper">
        <header class="header">
            <div id="navbar" class="navbar top flex-columns subpages">
                <div></div>
                <nav class="nav-right">
                    <ul>
                        <li><a href="../index.html">Home</a></li>
                        <li><a href="pages/education.html">Education</a></li>
                        <!-- <li><a href="pages/background.html">Background</a></li> -->
                    </ul>
                </nav>
            </div>
        </header>
        <div class="wrap">
            <h1>Game Playing Alorithm</h1>
            <div class="code">
                <pre><code class="python">
import random as rnd
import numpy as np
from datetime import datetime, timedelta

class GameState(object):
    __slots__ = ['board', 'playerToMove', 'winner']

# Global variables
boardWidth = 0
boardHeight = 0
homeWidth = 0
homeHeight = 0
timeLimit = 0

# Compute list of legal moves for a given GameState for the player moving next #
def getMoveOptions(state):
    direction = [[(1, 0), (0, 1)], [(-1, 0), (0, -1)]]             # Possible (dx, dy) moving directions for each player
    moves = []
    for xStart in range(boardWidth):                               # Search board for player's pieces
        for yStart in range(boardHeight):
            if state.board[xStart, yStart] == state.playerToMove:  # Found a piece!
                for (dx, dy) in direction[state.playerToMove]:     # Check horizontal and vertical moving directions
                    (xEnd, yEnd) = (xStart + dx, yStart + dy)
                    while xEnd >= 0 and xEnd < boardWidth and yEnd >= 0 and yEnd < boardHeight:
                        if state.board[xEnd, yEnd] == -1:
                            moves.append((xStart, yStart, xEnd, yEnd))  # If square is free, we have a legal move...
                            break
                        xEnd += dx                                 # Otherwise, check for larger step
                        yEnd += dy
    return moves


# For a given GameState and move to be executed, return the GameState that results from the move #
def makeMove(state, move):
    (xStart, yStart, xEnd, yEnd) = move
    newState = GameState()

    newState.playerToMove = 1 - state.playerToMove                 # After the move, it's the other player's turn
    newState.board = np.copy(state.board)
    newState.board[xStart, yStart] = -1                            # Remove the piece at the start position
    if (state.playerToMove == 0 and (xEnd < boardWidth - homeWidth or yEnd < boardHeight - homeHeight)) or \
            (state.playerToMove == 1 and (xEnd >= homeWidth or yEnd >= homeHeight)):
        newState.board[
            xEnd, yEnd] = state.playerToMove                       # Unless the move ends in the opponent's home, place piece at end position

    for xStart in range(boardWidth):
        for yStart in range(boardHeight):
            if newState.board[xStart, yStart] == state.playerToMove:
                newState.winner = -1                               # If the player still has pieces on the board, then there is no winner yet...
                return newState

    newState.winner = state.playerToMove                           # Otherwise, the current player has won!
    return newState




# Return the evaluation score for a given GameState; higher score indicates a better situation for Player 1
# Alan_Turing's evaluation function is based on the (non-jump) moves each player would need to win the game.
def getScore(state):
    score = 0
    for x in range(boardWidth):                             # Search board for any pieces
        for y in range(boardHeight):
            if state.board[x, y] == 0:                      # Subtract the number of moves (non-jumps) for Player 1's piece to reach Player 2's home area
                score -= max([0, boardWidth - homeWidth - x]) + max([0, boardHeight - homeHeight - y])
            else:
                if state.board[x, y] == 1:                  # Add the number of moves (non-jumps) for Player 2's piece to reach Player 1's home area
                    score += max([0, x - homeWidth + 1]) + max([0, y - homeHeight + 1])
    return score


def timeOut(startTime, timeLimit):
    duration = datetime.now() - startTime
    return duration.seconds + duration.microseconds * 1e-6 >= timeLimit


def iterativeDeepeningMinimax(state, timeLimit):

    current_depth = 2                                   # Define the depth of the computation
    scores = []

    startTime = datetime.now()                          # Launch timer
    endTime = startTime + timedelta(seconds=timeLimit)

    while True:
        if timeOut(startTime, timeLimit):
            break

        # Calculate remaining time to run minimax
        currentTime = datetime.now()
        remainingTime = divmod((endTime - currentTime).total_seconds(), 60)[1]

        # Calculate the score up to the current depth
        scores.append(miniMax(state, current_depth, -9999, 9999, currentTime, remainingTime))

        # Iteratively go deeper
        current_depth += 1

    return np.nanmax(np.array(scores, dtype=np.float16))


def miniMax(state, depth, alpha, beta, startTime, timeLimit):
    # If timeout, stop doing minimax, return None so that the result won't be count
    if timeOut(startTime, timeLimit):
        return None

    # If we reach the desired depth of the minimax tree, or we have a winner at a state, return the score of that state
    if depth == 0 or state.winner != -1:
        return getScore(state)

    moveList = getMoveOptions(state)

    if state.playerToMove == 0:
        # Player 1 Turn (Max Turn)
        for move in moveList:
            projectedState = makeMove(state, move)
            # Recursively call minimax on the lower level (reduce the depth by 1)
            result = miniMax(projectedState, depth - 1, alpha, beta, startTime, timeLimit)

            # If our minimax run out of time (return value is None), return None so that the result won't be count
            if result is None:
                return None

            alpha = max(alpha, result)

            # Alpha - Beta Pruning
            if beta <= alpha:
                return alpha

        return alpha
    else:
        # Player 2 Turn (Min Turn)
        for move in moveList:
            projectedState = makeMove(state, move)
            # Recursively call minimax on the lower level (reduce the depth by 1)
            result = miniMax(projectedState, depth - 1, alpha, beta, startTime, timeLimit)

            # If our minimax run out of time (return value is None), return None so that the result won't be count
            if result is None:
                return None

            beta = min(beta, result)

            # Alpha - Beta Pruning
            if beta <= alpha:
                return beta

        return beta


def getMove(state, hWidth, hHeight, timeLimit):
    # Set global variables
    global boardWidth, boardHeight, homeWidth, homeHeight
    boardWidth = state.board.shape[0]
    boardHeight = state.board.shape[1]
    homeWidth = hWidth
    homeHeight = hHeight
    
    #print("Playere Number:", state.playerToMove)

    moveList = getMoveOptions(state)  # Get the list of possible moves
    bestMoveSoFar = moveList[0]
    scoreList = []
    stateList = dict()

    for move in moveList:
    
        projectedState = makeMove(state, move)                              # For each move, play it on a separate board
        stateList[projectedState] = (move, getScore(projectedState))

    stateList = sorted(stateList.items(), key=lambda kv: kv[1][1], reverse=(state.playerToMove == 0))

    for projectedState, _ in stateList:
        
        scoreList.append(iterativeDeepeningMinimax(projectedState, timeLimit / len(moveList)))  # Call the evaluation function on the resulting GameState

    if state.playerToMove == 0:  # Finally, pick the move with the best score
        bestMoveSoFar = stateList[scoreList.index(max(scoreList))][1][0]  # If we are Player 1, we look for the maximum score
    else:
        bestMoveSoFar = stateList[scoreList.index(min(scoreList))][1][0]  # If we are Player 2, we look for the minimum score

    return bestMoveSoFar


        </code></pre>
            </div>
        </div>
        <footer class="foot">
            <a class="btn" href="../index.html">Main Page</a>
        </footer>
    </div>
</body>

</html>